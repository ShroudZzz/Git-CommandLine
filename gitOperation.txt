git 检测有没有安装git
git sudo apt-get install git git安装
git init  切换到目标目录 会建立空的仓库
git ls -ah 查看所有文件(隐藏)
git add 提交代码 将工作区的修改存放至暂存区
git commit -m”描述” (多次add  一次commit)
git status命令可以让我们时刻掌握仓库当前的状态
git diff <File> 查看具体修改的内容 (没有add前)
git log 查看版本历史记录 git log --pretty=oneline
git reset —-head HEAD^ 
在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID        和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。
git git reset —-hard <版本ID 号> 可以恢复指定当前版本
git reflog git命令记录 可用于追溯 恢复新版本
注意 Zzz
git add把文件添加进去，实际上就是把文件修改添加到暂存区 git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
cat <File>  查看文件
注意  Zzz
第一次修改 -> git add -> 第二次修改 -> git commit
你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别：
git checkout -- <File> 丢弃工作区的修改 工作区的修改全部撤销 让这个文件回到最近一次git commit或git add时的状态。
git reset HEAD <File> 命令既可以回退版本，也可以把暂存区的修改回退到工作区 之后丢弃修改就是上面的命令
rm <File> 删除文件 git status 可以看见删除状态 
git rm <File> 删除版本库中的文件
git check —- <File> (误删)复原 git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。
**************************************************************************************
远程仓库
第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：

$ ssh-keygen -t rsa -C "youremail@example.com"
你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。

如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：

然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：
为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。

当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。

最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。

如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。
**************************************************************************************
添加远程仓库
1.在GitHub上创建新的仓库
2.在本地仓库路径上 git remote add origin <仓库地址>https://github.com/VermouthC/learngit.git
3.本地库的所有内容推送到远程库上 $ git push -u origin master
我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
4.只要本地作了提交，就可以通过命令 $ git push origin master
**************************************************************************************
克隆远程仓库 
git clone <仓库地址>

**************************************************************************************
创建分支
git checkout -b ‘<分支名称>’
git checkout命令加上-b参数表示创建并切换
相当于以下两条命令：
git branch <分支名称> 创建
git checkout <分支名称> 切换

git branch 查看当前分支
git branch命令会列出所有分支，当前分支前面会标一个*号
提交时就针对于分支
git add readme.txt 
git commit -m "branch test"

dev分支的工作完成，我们就可以切换回master分支：
git checkout master
此时查看文件 分支的改动均不会体现,此时需要合并
git merge <分支名称>

合并完成后就可以删除分支
git branch -d <分支名称>

此时查看branch，就只剩下master分支了 (git branch)
**************************************************************************************
合并分支
git log --graph命令可以看到分支合并图。(git log --graph --pretty=oneline --abbrev-commit)

git merge feature1
Auto-merging readme.txt
CONFLICT (content): Merge conflict in <冲突文件名>
Automatic merge failed; fix conflicts and then commit the result.

git status也可以告诉我们冲突的文件

冲突内容标注
<<<<<<< HEAD<主分支>
Creating a new branch is quick & simple.
=======
Creating a new branch is quick AND simple.
>>>>>>> dev<其他分支>

修改后提交

**************************************************************************************

分支策略
git merge --no-ff -m "merge with no-ff" <分支名称>
git merge --no-ff -m "merge with no-ff" dev
查看分支历史
git log --graph --pretty=oneline --abbrev-commit
**************************************************************************************
Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：
用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。

解决流程
1.首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：
git checkout master 切换到主分支
git checkout -b issue-101
2.现在修复bug 然后提交
git add readme.txt
git commit -m "fix bug 101"
3.修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：
git checkout master
$ git merge --no-ff -m "merged bug fix 101" issue-101
git branch -d issue-101
4.接着回到原来你的分支干活了
git checkout dev
git status 工作区干净的Zzz
5.Git把stash内容存在某个地方了，但是需要恢复
git stash list 存储列表
git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
git stash pop，恢复的同时把stash内容也删了
注意:
多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：

$ git stash apply stash@{0}

**************************************************************************************
$ git branch -D <分支名称> 强行删除

**************************************************************************************
查看远程库的信息
git remote 
git remote -v 显示更详细的信息
显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。

推送分支
git push origin <远程分支名>
远程推送原则
master分支是主分支，因此要时刻与远程同步；
dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。

**************************************************************************************
多人协作 
先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送
注意 指定本地dev分支与远程origin/dev分支的链接 git branch --set-upstream dev origin/<branch>
git pull 拉取
合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push

小结
1.查看远程库信息，使用git remote -v
2.本地新建的分支如果不推送到远程，对其他人就是不可见的
3.从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交
4.在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致
5.建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name
6.从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。
**************************************************************************************
标签
创建标签
git branch 查看git 分支
git checkout master 切换分支
git tag <name> 创建新标签  (git tag 所有标签)
注意 
默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？
方法是找到历史提交的commit id，然后打上就可以了
git log --pretty=oneline --abbrev-commit 历史记录
git tag <tagName> <id(6224937)>
git show <tagname>  查看标签信息
git tag -a v0.1 -m "version 0.1 released" 3628164 创建带有说明的标签，用-a指定标签名，-m指定说明文字

操作标签
git tag -d v0.1 删除标签
git push origin <tagname> 推送某个标签到远程
git push origin --tags 一次性推送全部尚未推送到远程的本地标签：

标签已经推送到远程 先从本地删除
git tag -d v0.9
然后，从远程删除。删除命令也是push
git push origin :refs/tags/<标签名称>
**************************************************************************************
配置别名
敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。

我们只需要敲一行命令，告诉Git，以后st就表示status：

git config --global alias.st status

用co表示checkout，ci表示commit，br表示branch：

$ git config --global alias.co checkout
$ git config --global alias.ci commit
$ git config --global alias.br branch

在撤销修改中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：
git config --global alias.unstage 'reset HEAD'

配置一个git last，让其显示最后一次提交信息：
git config --global alias.last 'log -1’git

lg配置成了
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit”(Zzz)

配置Git的时候,加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用

配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：cat .git/config

**************************************************************************************

搭建Git服务器

阅读: 594749
在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。

GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。

搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。

假设你已经有sudo权限的用户账号，下面，正式开始安装。

第一步，安装git：

$ sudo apt-get install git
第二步，创建一个git用户，用来运行git服务：

$ sudo adduser git
第三步，创建证书登录：

收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。

第四步，初始化Git仓库：

先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：

$ sudo git init --bare sample.git
Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：

$ sudo chown -R git:git sample.git
第五步，禁用shell登录：

出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：

git:x:1001:1001:,,,:/home/git:/bin/bash
改为：

git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。

第六步，克隆远程仓库：

现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：

$ git clone git@server:/srv/sample.git
Cloning into 'sample'...
warning: You appear to have cloned an empty repository.
剩下的推送就简单了。

管理公钥

如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。

这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。

管理权限

有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。

这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。
